# Epic 3 Retrospective: POS & Ventes - Commandes, Encaissement & Sessions

**Date**: 2026-02-02
**Epic**: Epic 3 - POS & Ventes
**Status**: Done (Synthetic Retrospective)
**Stories Completed**: 8/8

---

## Executive Summary

Epic 3 a implémenté le coeur du système POS avec création de commandes offline, gestion du panier persistant, traitement des paiements offline, et le sync queue complet. C'est l'epic le plus critique car il gère les transactions financières. L'introduction du kitchen dispatch via LAN a préparé le terrain pour Epic 4 (KDS).

---

## What Went Well

### 1. Sync Queue Robuste
- Pattern FIFO avec retry exponential backoff
- Limite de 4 retries (5s → 10s → 20s → 40s)
- Reconciliation intelligente des conflits
- Indicateur visuel du nombre d'items en attente

### 2. Cart Persistence
- Panier sauvegardé automatiquement dans localStorage
- Restauration au refresh/reload
- Support des items locked (envoyés en cuisine)

### 3. Offline Order Creation
- Préfixe `LOCAL-` pour les order_id générés offline
- Replacement par UUID serveur après sync
- Intégrité référentielle maintenue

### 4. Kitchen Dispatch Foundation
- `kitchenDispatchService` pour envoi LAN
- Queue de dispatch avec retry
- Filtrage par dispatch_station (kitchen, barista, display)
- Base solide pour Epic 4 KDS

---

## Challenges & Solutions

### Challenge 1: Gestion des IDs Offline
**Problème**: Les orders créés offline n'ont pas d'UUID serveur
**Solution**: Préfixe `LOCAL-{timestamp}-{random}` remplacé après sync
```typescript
const offlineOrderId = `LOCAL-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
// After sync: replaced with server UUID
```
**Impact**: Pattern réutilisé pour tous les entities créés offline

### Challenge 2: Sync Conflicts
**Problème**: Même order modifié offline et online simultanément
**Solution**:
- Timestamp comparison (`updated_at`)
- Server wins for critical fields (amounts, status)
- Client wins for metadata (notes)
**Impact**: Règles de reconciliation documentées

### Challenge 3: Payment Processing Offline
**Problème**: Validation des paiements sans connexion serveur
**Solution**:
- Validation côté client des montants
- Queue des paiements pour sync
- Marquage `is_offline: true`
**Impact**: Aucune transaction perdue même en panne réseau prolongée

### Challenge 4: LAN Hub Integration
**Problème**: Browsers ne peuvent pas créer de WebSocket servers natifs
**Solution**: BroadcastChannel API + Supabase Realtime comme fallback
```typescript
// Primary: BroadcastChannel (same origin, fast)
// Fallback: Supabase Realtime (cross-origin, reliable)
```
**Impact**: Architecture validée et utilisée dans Epic 4

---

## Technical Decisions Made

| Decision | Rationale | Status |
|----------|-----------|--------|
| LOCAL- prefix pattern | Identification claire des entities offline | Validé |
| Exponential backoff | Évite surcharge serveur après reconnexion | Validé |
| Server wins conflicts | Intégrité financière prioritaire | Validé |
| BroadcastChannel + Realtime | Browsers ne supportent pas WS server | Validé |
| Dispatch queue | Resilience aux pannes LAN | Validé |
| is_offline flag | Traçabilité pour audit | Validé |

---

## Patterns Established

### 1. Sync Queue Pattern
```
1. Create operation locally
2. Add to syncQueue with metadata
3. Process FIFO when online
4. Retry with backoff on failure
5. Reconcile server response
```

### 2. Offline Entity Pattern
```typescript
interface IOfflineOrder {
  local_id: string;        // LOCAL-xxx (offline) or UUID (synced)
  server_id?: string;      // Set after sync
  is_synced: boolean;
  sync_attempts: number;
  last_sync_error?: string;
}
```

### 3. Kitchen Dispatch Pattern
```
1. Filter items by category.dispatch_station
2. Group by station
3. Emit via BroadcastChannel
4. Queue if no ACK received
5. Retry from queue
```

---

## Metrics

| Metric | Value |
|--------|-------|
| Stories Completed | 8/8 (100%) |
| Tests Written | ~25 |
| New Services | 5 (syncQueue, orderSync, paymentSync, kitchenDispatchService, syncEngine) |
| New Hooks | 6 |
| Dexie Stores Added | 3 (offlineOrders, offlineOrderItems, offlineSyncQueue) |
| Critical Paths Tested | Order creation, payment, sync |

---

## Recommendations for Future Epics

1. **Utiliser le pattern LOCAL- prefix** pour toute entity créée offline
2. **Toujours marquer is_offline** pour la traçabilité
3. **Server wins pour les données financières** - jamais de compromis
4. **Tester les scénarios de sync** avec network throttling
5. **BroadcastChannel comme primary** pour communication inter-tabs/devices sur même réseau

---

## Files Created/Modified

### Services
- `src/services/sync/syncQueue.ts`
- `src/services/sync/syncEngine.ts`
- `src/services/sync/orderSync.ts`
- `src/services/sync/paymentSync.ts`
- `src/services/lan/kitchenDispatchService.ts`
- `src/services/lan/lanHub.ts`
- `src/services/lan/lanClient.ts`
- `src/services/lan/lanProtocol.ts`

### Hooks
- `src/hooks/useSyncQueue.ts`
- `src/hooks/useOfflineOrder.ts`
- `src/hooks/useOfflinePayment.ts`
- `src/hooks/shift/useShiftOffline.ts`

### Stores
- `src/stores/syncStore.ts`
- `src/stores/cartStore.ts` (enhanced)

### Components
- `src/components/sync/SyncIndicator.tsx`
- `src/components/sync/PendingSyncCounter.tsx`

### Database
- `src/lib/db.ts` (added offlineOrders, offlineOrderItems, offlineSyncQueue)

### Types
- `src/types/offline.ts` (IOfflineOrder, IOfflineOrderItem, ISyncQueueItem)

---

## Lessons Learned

1. **Les transactions financières offline sont possibles** avec une architecture robuste
2. **La reconciliation doit être déterministe** - pas d'ambiguïté sur qui gagne
3. **Le LAN dispatch est un bonus** - l'app doit fonctionner sans
4. **Tester les edge cases de sync** - ils arrivent plus souvent qu'on pense

---

## Impact on Epic 4

Epic 3 a posé les bases essentielles pour le KDS:
- `kitchenDispatchService` prêt à être consommé
- `lanProtocol.ts` définit les message types
- Filtrage par `dispatch_station` implémenté
- BroadcastChannel pattern validé

---

*Note: Cette rétrospective a été générée synthétiquement à partir des fichiers de stories pour établir une baseline documentée.*
