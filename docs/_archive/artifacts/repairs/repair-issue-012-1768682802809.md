## âœ… [ISSUE-012] No Data Validation on Critical Operations - IMPLEMENTED

### Files Created/Modified

- âœ… src/utils/validators.ts
- âœ… src/hooks/useFormValidation.ts
- âœ… src/components/pos/PaymentModal.tsx (updated)
- âœ… src/components/inventory/StockAdjustmentModal.tsx (updated)
- âœ… src/components/products/ProductForm.tsx (updated)
- âœ… src/utils/formatters.ts

### Changes Summary

Implemented comprehensive data validation system for all critical operations including payment validation, stock management, price validation, and Indonesian-specific validations (IDR currency, phone numbers). Added form validation hooks and updated critical components to use proper validation.

### Code Implementation

**1. Core Validators**

```typescript
// src/utils/validators.ts
export class ValidationError extends Error {
  constructor(message: string, public field?: string) {
    super(message);
    this.name = 'ValidationError';
    this.field = field;
  }
}

export interface ValidationResult {
  isValid: boolean;
  errors: Record<string, string>;
}

export const validators = {
  // Payment validation
  validatePayment(amount: number, total: number): void {
    if (!Number.isFinite(amount)) {
      throw new ValidationError('Montant invalide', 'amount');
    }
    if (amount < 0) {
      throw new ValidationError('Le montant ne peut pas Ãªtre nÃ©gatif', 'amount');
    }
    if (amount < total) {
      throw new ValidationError(
        `Montant insuffisant. Total: Rp ${total.toLocaleString('id-ID')}`,
        'amount'
      );
    }
    // Check for reasonable maximum (100 million IDR)
    if (amount > 100_000_000) {
      throw new ValidationError('Montant trop Ã©levÃ©', 'amount');
    }
  },

  // Stock validation
  validateStockQuantity(quantity: number, maxStock?: number, minStock: number = 0): void {
    if (!Number.isInteger(quantity)) {
      throw new ValidationError('La quantitÃ© doit Ãªtre un nombre entier', 'quantity');
    }
    if (quantity < minStock) {
      throw new ValidationError(`La quantitÃ© ne peut pas Ãªtre infÃ©rieure Ã  ${minStock}`, 'quantity');
    }
    if (maxStock !== undefined && quantity > maxStock) {
      throw new ValidationError(`QuantitÃ© maximum: ${maxStock}`, 'quantity');
    }
  },

  // Price validation
  validatePrice(price: number): void {
    if (!Number.isFinite(price)) {
      throw new ValidationError('Prix invalide', 'price');
    }
    if (price <= 0) {
      throw new ValidationError('Le prix doit Ãªtre supÃ©rieur Ã  0', 'price');
    }
    if (price > 100_000_000) {
      throw new ValidationError('Prix trop Ã©levÃ© (max: Rp 100,000,000)', 'price');
    }
    // IDR typically doesn't use decimals in retail
    if (price % 1 !== 0) {
      throw new ValidationError('Les prix en IDR doivent Ãªtre des nombres entiers', 'price');
    }
  },

  // IDR currency validation
  validateIDR(amount: number): void {
    if (!Number.isFinite(amount)) {
      throw new ValidationError('Montant IDR invalide', 'amount');
    }
    // IDR doesn't use decimal places
    if (amount % 1 !== 0) {
      throw new ValidationError('Les montants en IDR ne doivent pas avoir de dÃ©cimales', 'amount');
    }
    if (amount < 0) {
      throw new ValidationError('Le montant ne peut pas Ãªtre nÃ©gatif', 'amount');
    }
  },

  // Email validation
  validateEmail(email: string): void {
    if (!email || email.trim() === '') {
      throw new ValidationError('Email requis', 'email');
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      throw new ValidationError('Format email invalide', 'email');
    }
  },

  // Indonesian phone validation
  validatePhone(phone: string): void {
    if (!phone || phone.trim() === '') {
      throw new ValidationError('NumÃ©ro de tÃ©lÃ©phone requis', 'phone');
    }
    // Remove all spaces and dashes for validation
    const cleanPhone = phone.replace(/[\s-]/g, '');
    // Indonesian phone formats: +62xxx, 62xxx, 08xxx
    const phoneRegex = /^(\+62|62|0)[0-9]{8,12}$/;
    if (!phoneRegex.test(cleanPhone)) {
      throw new ValidationError(
        'Format invalide. Utilisez: +62xxx, 62xxx, ou 08xxx (8-12 chiffres)',
        'phone'
      );
    }
  },

  // Product name validation
  validateProductName(name: string): void {
    if (!name || name.trim() === '') {
      throw new ValidationError('Nom du produit requis', 'name');
    }
    if (name.trim().length < 2) {
      throw new ValidationError('Le nom doit contenir au moins 2 caractÃ¨res', 'name');
    }
    if (name.trim().length > 100) {
      throw new ValidationError('Le nom ne peut pas dÃ©passer 100 caractÃ¨res', 'name');
    }
  },

  // Category validation
  validateCategory(category: string): void {
    const validCategories = [
      'pain', 'viennoiseries', 'patisseries', 'boissons', 'sandwiches', 'autres'
    ];
    if (!category || !validCategories.includes(category.toLowerCase())) {
      throw new ValidationError(
        `CatÃ©gorie invalide. Choix: ${validCategories.join(', ')}`,
        'category'
      );
    }
  },

  // Discount validation
  validateDiscount(discount: number, isPercentage: boolean = true): void {
    if (!Number.isFinite(discount)) {
      throw new ValidationError('Remise invalide', 'discount');
    }
    if (discount < 0) {
      throw new ValidationError('La remise ne peut pas Ãªtre nÃ©gative', 'discount');
    }
    if (isPercentage && discount > 100) {
      throw new ValidationError('La remise ne peut pas dÃ©passer 100%', 'discount');
    }
    if (!isPercentage && discount > 50_000_000) { // 50M IDR max discount
      throw new ValidationError('Remise trop Ã©levÃ©e', 'discount');
    }
  },

  // Date validation
  validateDate(date: string | Date): Date {
    const parsedDate = new Date(date);
    if (isNaN(parsedDate.getTime())) {
      throw new ValidationError('Date invalide', 'date');
    }
    // Check if date is not too far in the past (more than 10 years)
    const tenYearsAgo = new Date();
    tenYearsAgo.setFullYear(tenYearsAgo.getFullYear() - 10);
    if (parsedDate < tenYearsAgo) {
      throw new ValidationError('Date trop ancienne', 'date');
    }
    // Check if date is not too far in the future (more than 1 year)
    const oneYearFromNow = new Date();
    oneYearFromNow.setFullYear(oneYearFromNow.getFullYear() + 1);
    if (parsedDate > oneYearFromNow) {
      throw new ValidationError('Date trop Ã©loignÃ©e dans le futur', 'date');
    }
    return parsedDate;
  },

  // Batch validation for forms
  validateForm<T extends Record<string, any>>(
    data: T,
    rules: Record<keyof T, (value: any) => void>
  ): ValidationResult {
    const errors: Record<string, string> = {};
    let isValid = true;

    for (const [field, validator] of Object.entries(rules)) {
      try {
        validator(data[field]);
      } catch (error) {
        if (error instanceof ValidationError) {
          errors[field] = error.message;
          isValid = false;
        }
      }
    }

    return { isValid, errors };
  },
};

// Specific business logic validators
export const businessValidators = {
  // Check if enough stock is available for sale
  validateSaleQuantity(requestedQty: number, availableStock: number, productName: string): void {
    validators.validateStockQuantity(requestedQty, availableStock, 1);
    if (requestedQty > availableStock) {
      throw new ValidationError(
        `Stock insuffisant pour ${productName}. Disponible: ${availableStock}`,
        'quantity'
      );
    }
  },

  // Validate cash payment has enough change
  validateCashPayment(payment: number, total: number, availableChange: number = 1_000_000): void {
    validators.validatePayment(payment, total);
    const changeNeeded = payment - total;
    if (changeNeeded > availableChange) {
      throw new ValidationError(
        `Change insuffisante en caisse. Change nÃ©cessaire: Rp ${changeNeeded.toLocaleString('id-ID')}`,
        'payment'
      );
    }
  },

  // Validate inventory adjustment reasons
  validateAdjustmentReason(reason: string, type: 'increase' | 'decrease'): void {
    const validReasons = {
      increase: ['restock', 'correction', 'return', 'production'],
      decrease: ['sale', 'waste', 'damage', 'theft', 'correction']
    };
    
    if (!reason || !validReasons[type].includes(reason)) {
      throw new ValidationError(
        `Raison invalide pour ${type}. Choix: ${validReasons[type].join(', ')}`,
        'reason'
      );
    }
  },
};
```

**2. Form Validation Hook**

```typescript
// src/hooks/useFormValidation.ts
import { useState, useCallback, useEffect } from 'react';
import { ValidationResult, validators } from '@/utils/validators';

interface UseFormValidationOptions<T> {
  initialValues: T;
  validationRules: Record<keyof T, (value: any) => void>;
  onSubmit: (values: T) => Promise<void> | void;
  validateOnChange?: boolean;
}

interface FormState<T> {
  values: T;
  errors: Record<keyof T, string>;
  touched: Record<keyof T, boolean>;
  isValid: boolean;
  isSubmitting: boolean;
}

export function useFormValidation<T extends Record<string, any>>({
  initialValues,
  validationRules,
  onSubmit,
  validateOnChange = true,
}: UseFormValidationOptions<T>) {
  const [state, setState] = useState<FormState<T>>({
    values: initialValues,
    errors: {} as Record<keyof T, string>,
    touched: {} as Record<keyof T, boolean>,
    isValid: false,
    isSubmitting: false,
  });

  // Validate all fields
  const validateAll = useCallback((): ValidationResult => {
    return validators.validateForm(state.values, validationRules);
  }, [state.values, validationRules]);

  // Validate single field
  const validateField = useCallback((field: keyof T, value: any): string | null => {
    try {
      const rule = validationRules[field];
      if (rule) {
        rule(value);
      }
      return null;
    } catch (error) {
      if (error instanceof Error) {
        return error.message;
      }
      return 'Erreur de validation';
    }
  }, [validationRules]);

  // Update field value
  const setValue = useCallback((field: keyof T, value: any) => {
    setState(prev => {
      const newValues = { ...prev.values, [field]: value };
      const errors = { ...prev.errors };
      
      // Validate on change if enabled
      if (validateOnChange && prev.touched[field]) {
        const fieldError = validateField(field, value);
        if (fieldError) {
          errors[field] = fieldError;
        } else {
          delete errors[field];
        }
      }
      
      return {
        ...prev,
        values: newValues,
        errors,
        isValid: Object.keys(errors).length === 0,
      };
    });
  }, [validateField, validateOnChange]);

  // Mark field as touched
  const setTouched = useCallback((field: keyof T, touched: boolean = true) => {
    setState(prev => ({
      ...prev,
      touched: { ...prev.touched, [field]: touched },
    }));
  }, []);

  // Handle form submission
  const handleSubmit = useCallback(async (e?: React.FormEvent) => {
    if (e) {
      e.preventDefault();
    }

    // Mark all fields as touched
    const allTouched = Object.keys(initialValues).reduce((acc, key) => {
      acc[key as keyof T] = true;
      return acc;
    }, {} as Record<keyof T, boolean>);

    setState(prev => ({ ...prev, touched: allTouched }));

    // Validate all fields
    const validation = validateAll();
    
    setState(prev => ({
      ...prev,
      errors: validation.errors as Record<keyof T, string>,
      isValid: validation.isValid,
      isSubmitting: validation.isValid,
    }));

    if (validation.isValid) {
      try {
        await onSubmit(state.values);
        // Reset form on successful submit
        setState(prev => ({
          ...prev,
          isSubmitting: false,
          touched: {} as Record<keyof T, boolean>,
        }));
      } catch (error) {
        setState(prev => ({
          ...prev,
          isSubmitting: false,
        }));
        throw error;
      }
    }
  }, [initialValues, validateAll, onSubmit, state.values]);

  // Reset form
  const reset = useCallback(() => {
    setState({
      values: initialValues,
      errors: {} as Record<keyof T, string>,
      touched: {} as Record<keyof T, boolean>,
      isValid: false,
      isSubmitting: false,
    });
  }, [initialValues]);

  // Update validation on values change
  useEffect(() => {
    const validation = validateAll();
    setState(prev => ({
      ...prev,
      isValid: validation.isValid,
    }));
  }, [state.values, validateAll]);

  return {
    values: state.values,
    errors: state.errors,
    touched: state.touched,
    isValid: state.isValid,
    isSubmitting: state.isSubmitting,
    setValue,
    setTouched,
    handleSubmit,
    reset,
    validateField,
  };
}
```

**3. Currency Formatter**

```typescript
// src/utils/formatters.ts
export const formatCurrency = (amount: number, currency: string = 'IDR'): string => {
  if (!Number.isFinite(amount)) {
    return 'Rp 0';
  }

  // Indonesian Rupiah formatting
  if (currency === 'IDR') {
    return new Intl.NumberFormat('id-ID', {
      style: 'currency',
      currency: 'IDR',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(amount);
  }

  return new Intl.NumberFormat('fr-FR', {
    style: 'currency',
    currency,
    minimumFractionDigits: 2,
  }).format(amount);
};

export const parseIDRAmount = (value: string): number => {
  // Remove currency symbols and formatting
  const cleanValue = value.replace(/[Rp\s.,]/g, '');
  const parsed = parseInt(cleanValue, 10);
  return isNaN(parsed) ? 0 : parsed;
};

export const formatPhone = (phone: string): string => {
  // Format Indonesian phone numbers
  const cleaned = phone.replace(/\D/g, '');
  
  if (cleaned.startsWith('62')) {
    return `+${cleaned}`;
  } else if (cleaned.startsWith('0')) {
    return `+62${cleaned.slice(1)}`;
  }
  
  return phone;
};
```

**4. Updated PaymentModal Component**

```typescript
// src/components/pos/PaymentModal.tsx
import React, { useState } from 'react';
import { useFormValidation } from '@/hooks/useFormValidation';
import { validators, businessValidators } from '@/utils/validators';
import { formatCurrency, parseIDRAmount } from '@/utils/formatters';

interface PaymentModalProps {
  isOpen: boolean;
  onClose: () => void;
  total: number;
  onPaymentComplete: (paymentData: PaymentData) => Promise<void>;
  availableChange?: number;
}

interface PaymentData {
  method: 'cash' | 'card' | 'transfer';
  amount: number;
  change?: number;
  reference?: string;
}

interface PaymentFormValues {
  method: 'cash' | 'card' | 'transfer';
  amount: string;
  reference: string;
}

export const PaymentModal: React.FC<PaymentModalProps> = ({
  isOpen,
  onClose,
  total,
  onPaymentComplete,
  availableChange = 1_000_000,
}) => {
  const [paymentError, setPaymentError] = useState<string | null>(null);

  const {
    values,
    errors,
    touched,
    isValid,
    isSubmitting,
    setValue,
    setTouched,
    handleSubmit,
  } = useFormValidation<PaymentFormValues>({
    initialValues: {
      method: 'cash',
      amount: total.toString(),
      reference: '',
    },
    validationRules: {
      method: (value: string) => {
        if (!['cash', 'card', 'transfer'].includes(value)) {
          throw new Error('MÃ©thode de paiement invalide');
        }
      },
      amount: (value: string) => {
        const numAmount = parseIDRAmount(value);
        validators.validateIDR(numAmount);
        
        if (values.method === 'cash') {
          businessValidators.validateCashPayment(numAmount, total, availableChange);
        } else {
          validators.validatePayment(numAmount, total);
        }
      },
      reference: (value: string) => {
        if (values.method !== 'cash' && (!value || value.trim() === '')) {
          throw new Error('RÃ©fÃ©rence requise pour les paiements Ã©lectroniques');
        }
      },
    },
    onSubmit: async (formValues) => {
      try {
        setPaymentError(null);
        const amount = parseIDRAmount(formValues.amount);
        
        const paymentData: PaymentData = {
          method: formValues.method,
          amount,
          reference: formValues.method !== 'cash' ? formValues.reference : undefined,
        };

        if (formValues.method === 'cash' && amount > total) {
          paymentData.change = amount - total;
        }

        await onPaymentComplete(paymentData);
        onClose();
      } catch (error) {
        setPaymentError(error instanceof Error ? error.message : 'Erreur de paiement');
      }
    },
  });

  const calculatedChange = values.method === 'cash' 
    ? Math.max(0, parseIDRAmount(values.amount) - total)
    : 0;

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-md">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-bold">Paiement</h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700"
          >
            âœ•
          </button>
        </div>

        <div className="mb-6">
          <div className="bg-gray-100 p-4 rounded-lg">
            <div className="flex justify-between items-center">
              <span className="text-lg">Total Ã  payer:</span>
              <span className="text-xl font-bold text-blue-600">
                {formatCurrency(total)}
              </span>
            </div>
          </div>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          {/* Payment Method */}
          <div>
            <label className="block text-sm font-medium mb-2">
              MÃ©thode de paiement
            </label>
            <div className="grid grid-cols-3 gap-2">
              {(['cash', 'card', 'transfer'] as const).map((method) => (
                <button
                  key={method}
                  type="button"
                  onClick={() => setValue('method', method)}
                  className={`p-3 rounded-lg border-2 transition-colors ${
                    values.method === method
                      ? 'border-blue-500 bg-blue-50 text-blue-700'
                      : 'border-gray-200 hover:border-gray-300'
                  }`}
                >
                  <div className="text-center">
                    <div className="text-2xl mb-1">
                      {method === 'cash' && 'ðŸ’µ'}
                      {method === 'card' && 'ðŸ’³'}
                      {method === 'transfer' && 'ðŸ“±'}
                    </div>
                    <div className="text-xs">
                      {method === 'cash' && 'EspÃ¨ces'}
                      {method === 'card' && 'Carte'}
                      {method === 'transfer' && 'Virement'}
                    </div>
                  </div>
                </button>
              ))}
            </div>
          </div>

          {/* Amount */}
          <div>
            <label className="block text-sm font-medium mb-2">
              Montant reÃ§u
            </label>
            <div className="relative">
              <span className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500">
                Rp
              </span>
              <input
                type="text"
                value={values.amount}
                onChange={(e) => setValue('amount', e.target.value)}
                onBlur={() => setTouched('amount')}
                className={`w-full pl-8 pr-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 ${
                  touched.amount && errors.amount
                    ? 'border-red-500 focus:ring-red-500'
                    : 'border-gray-300'
                }`}
                placeholder="0"
              />
            </div>
            {touched.amount && errors.amount && (
              <p className="mt-1 text-sm text-red-600">{errors.amount}</p>
            )}
          </div>

          {/* Reference for non-cash payments */}
          {values.method !== 'cash' && (
            <div>
              <label className="block text-sm font-medium mb-2">
                RÃ©fÃ©rence/NumÃ©ro de transaction
              </label>
              <input
                type="text"
                value={values.reference}
                onChange={(e) => setValue('reference', e.target.value)}
                onBlur={() => setTouched('reference')}
                className={`w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500 ${
                  touched.reference && errors.reference
                    ? 'border-red-500 focus:ring-red-500'
                    : 'border-gray-300'
                }`}
                placeholder="Ex: 1234567890"
              />
              {touched.reference && errors.reference && (
                <p className="mt-1 text-sm text-red-600">{errors.reference}</p>
              )}
            </div>
          )}

          {/* Change calculation for cash */}
          {values.method === 'cash' && calculatedChange > 0 && (
            <div className="bg-green-50 p-4 rounded-lg">
              <div className="flex justify-between items-center">
                <span className="text-sm text-green-700">Monnaie Ã  rendre:</span>
                <span className="font-bold text-green-700">
                  {formatCurrency(calculatedChange)}
                </span>
              </div>
            </div>
          )}

          {/* Payment Error */}
          {paymentError && (
            <div className="bg-red-50 border border-red-200 rounded-lg p-3">
              <p className="text-sm text-red-600">{paymentError}</p>
            </div>
          )}

          {/* Action Buttons */}
          <div className="flex gap-3 pt-4">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
              disabled={isSubmitting}
            >
              Annuler
            </button>
            <button
              type="submit"
              disabled={!isValid || isSubmitting}
              className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isSubmitting ? 'Traitement...' : 'Confirmer le paiement'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};
```

**5. Updated StockAdjustmentModal Component**

```typescript
// src/components/inventory/StockAdjustmentModal.tsx
import React, { useState } from 'react';
import { useFormValidation } from '@/hooks/useFormValidation';
import { validators, businessValidators } from '@/utils/validators';

interface StockAdjustmentModalProps {
  isOpen: boolean;
  onClose: () => void;
  product: {
    id: string;
    name: string;
    currentStock: number;
    category: string;
  };
  onAdjustment: (adjustment: StockAdjustmentData) => Promise<void>;
}

interface StockAdjustmentData {
  productId: string;
  type: 'increase' | 'decrease';
  quantity: number;
  reason: string;
  notes?: string;
  newStock: number;
}

interface AdjustmentFormValues {
  type: 'increase' | 'decrease';
  quantity: string;
  reason: string;
  notes: string;
}

const ADJUSTMENT_REASONS = {
  increase: [
    { value: 'restock', label: 'RÃ©approvisionnement' },
    { value: 'correction', label: 'Correction inventaire' },
    { value: 'return', label: 'Retour client' },
    { value: 'production', label: 'Production interne' },
  ],
  decrease: [
    { value: 'sale', label: 'Vente' },
    { value: 'waste', label: 'DÃ©chet/PÃ©rimÃ©' },
    { value: 'damage', label: 'Dommage' },
    { value: 'theft', label: 'Vol/Perte' },
    { value: 'correction', label: 'Correction inventaire' },
  ],
};

export const StockAdjustmentModal: React.FC<StockAdjustmentModalProps> = ({
  isOpen,
  onClose,
  product,
  onAdjustment,
}) => {
  const [adjustmentError, setAdjustmentError] = useState<string | null>(null);

  const {
    values,
    errors,
    touched,
    isValid,
    isSubmitting,
    setValue,
    setTouched,
    handleSubmit,
  } = useFormValidation<AdjustmentFormValues>({
    initialValues: {
      type: 'increase',
      quantity: '',
      reason: '',
      notes: '',
    },
    validationRules: {
      type: (value: 'increase' | 'decrease') => {
        if (!['increase', 'decrease'].includes(value)) {
          throw new Error('Type d\'ajustement invalide');
        }
      },
      quantity: (value: string) => {
        const qty = parseInt(value, 10);
        if (isNaN(qty)) {
          throw new Error('QuantitÃ© requise');
        }
        validators.validateStockQuantity(qty, undefined, 1);
        
        // Check if decrease would result in negative stock
        if (values.type === 'decrease' && qty > product.currentStock) {
          throw new Error(`QuantitÃ© trop Ã©levÃ©e. Stock actuel: ${product.currentStock}`);
        }
      },
      reason: (value: string) => {
        businessValidators.validateAdjustmentReason(value, values.type);
      },
      notes: () => {}, // Notes are optional
    },
    onSubmit: async (formValues) => {
      try {
        setAdjustmentError(null);
        const quantity = parseInt(formValues.quantity, 10);
        
        const newStock = formValues.type === 'increase' 
          ? product.currentStock + quantity
          : product.currentStock - quantity;

        const adjustmentData: StockAdjustmentData = {
          productId: product.id,
          type: formValues.type,
          quantity,
          reason: formValues.reason,
          notes: formValues.notes || undefined,
          newStock,
        };

        await onAdjustment(adjustmentData);
        onClose();
      } catch (error) {
        setAdjustmentError(error instanceof Error ? error.message : 'Erreur d\'ajustement');
      }
    },
  });

  const calculatedNewStock = () => {
    const qty = parseInt(values.quantity, 10);
    if (isNaN(qty)) return product.currentStock;
    
    return values.type === 'increase'
      ? product.currentStock + qty
      : product.currentStock - qty;
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max