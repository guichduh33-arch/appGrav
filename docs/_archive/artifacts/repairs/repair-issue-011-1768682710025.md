## ✅ [ISSUE-011] No Offline Capability for POS System - IMPLEMENTED

### Files Created/Modified

- ✅ `src/services/offlineService.ts`
- ✅ `src/services/syncService.ts`
- ✅ `src/hooks/useOfflineSync.ts`
- ✅ `src/hooks/useNetworkStatus.ts`
- ✅ `src/components/ui/OfflineIndicator.tsx`
- ✅ `src/stores/offlineStore.ts`
- ✅ `public/sw.js`
- ✅ `src/main.tsx` (modified)
- ✅ `src/pages/pos/POSMenu.tsx` (modified)
- ✅ `src/pages/pos/PaymentModal.tsx` (modified)
- ✅ `vite.config.ts` (modified)

### Changes Summary

Implemented comprehensive offline capability for the POS system with:
- Service Worker for caching static resources
- IndexedDB for offline data storage
- Background sync for pending transactions
- Network status detection and UI indicators
- Offline-first POS operations with automatic sync when online

### Code Implementation

#### 1. Offline Service - IndexedDB Management

```typescript
// src/services/offlineService.ts
import { openDB, DBSchema, IDBPDatabase } from 'idb';

interface BreakeryDB extends DBSchema {
  sales: {
    key: string;
    value: {
      id: string;
      items: Array<{
        product_id: string;
        product_name: string;
        quantity: number;
        price: number;
        subtotal: number;
      }>;
      total: number;
      payment_method: 'cash' | 'card';
      amount_paid: number;
      change: number;
      customer_id?: string;
      created_at: string;
      synced: boolean;
      sync_attempts: number;
      last_sync_attempt?: string;
      error_message?: string;
    };
  };
  products: {
    key: string;
    value: {
      id: string;
      name: string;
      price: number;
      category: string;
      stock_quantity: number;
      image_url?: string;
      description?: string;
      is_active: boolean;
      last_updated: string;
    };
  };
  categories: {
    key: string;
    value: {
      id: string;
      name: string;
      description?: string;
      is_active: boolean;
      last_updated: string;
    };
  };
  sync_queue: {
    key: string;
    value: {
      id: string;
      type: 'sale' | 'stock_update' | 'product_update';
      data: any;
      created_at: string;
      attempts: number;
      last_attempt?: string;
      error?: string;
    };
  };
}

class OfflineService {
  private db: IDBPDatabase<BreakeryDB> | null = null;
  private readonly DB_NAME = 'breakery-pos-db';
  private readonly DB_VERSION = 1;

  async init(): Promise<void> {
    try {
      this.db = await openDB<BreakeryDB>(this.DB_NAME, this.DB_VERSION, {
        upgrade(db) {
          // Sales store - for offline transactions
          if (!db.objectStoreNames.contains('sales')) {
            const salesStore = db.createObjectStore('sales', { keyPath: 'id' });
            salesStore.createIndex('synced', 'synced', { unique: false });
            salesStore.createIndex('created_at', 'created_at', { unique: false });
          }

          // Products cache - for offline browsing
          if (!db.objectStoreNames.contains('products')) {
            const productsStore = db.createObjectStore('products', { keyPath: 'id' });
            productsStore.createIndex('category', 'category', { unique: false });
            productsStore.createIndex('is_active', 'is_active', { unique: false });
          }

          // Categories cache
          if (!db.objectStoreNames.contains('categories')) {
            const categoriesStore = db.createObjectStore('categories', { keyPath: 'id' });
            categoriesStore.createIndex('is_active', 'is_active', { unique: false });
          }

          // Sync queue - for failed operations
          if (!db.objectStoreNames.contains('sync_queue')) {
            const syncStore = db.createObjectStore('sync_queue', { keyPath: 'id' });
            syncStore.createIndex('type', 'type', { unique: false });
            syncStore.createIndex('created_at', 'created_at', { unique: false });
          }
        },
      });
      console.log('OfflineService initialized successfully');
    } catch (error) {
      console.error('Failed to initialize OfflineService:', error);
      throw new Error('Could not initialize offline storage');
    }
  }

  private async ensureDB(): Promise<IDBPDatabase<BreakeryDB>> {
    if (!this.db) {
      await this.init();
    }
    if (!this.db) {
      throw new Error('Database not initialized');
    }
    return this.db;
  }

  // SALES MANAGEMENT
  async saveOfflineSale(sale: Omit<BreakeryDB['sales']['value'], 'synced' | 'sync_attempts'>): Promise<void> {
    const db = await this.ensureDB();
    const offlineSale: BreakeryDB['sales']['value'] = {
      ...sale,
      synced: false,
      sync_attempts: 0,
    };

    try {
      await db.put('sales', offlineSale);
      console.log('Sale saved offline:', sale.id);
    } catch (error) {
      console.error('Failed to save offline sale:', error);
      throw new Error('Could not save sale offline');
    }
  }

  async getPendingSales(): Promise<BreakeryDB['sales']['value'][]> {
    const db = await this.ensureDB();
    try {
      const allSales = await db.getAllFromIndex('sales', 'synced', false);
      return allSales.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
    } catch (error) {
      console.error('Failed to get pending sales:', error);
      return [];
    }
  }

  async markSaleAsSynced(saleId: string): Promise<void> {
    const db = await this.ensureDB();
    try {
      const sale = await db.get('sales', saleId);
      if (sale) {
        sale.synced = true;
        sale.error_message = undefined;
        await db.put('sales', sale);
        console.log('Sale marked as synced:', saleId);
      }
    } catch (error) {
      console.error('Failed to mark sale as synced:', error);
    }
  }

  async markSaleSyncError(saleId: string, error: string): Promise<void> {
    const db = await this.ensureDB();
    try {
      const sale = await db.get('sales', saleId);
      if (sale) {
        sale.sync_attempts += 1;
        sale.last_sync_attempt = new Date().toISOString();
        sale.error_message = error;
        await db.put('sales', sale);
        console.log('Sale sync error recorded:', saleId, error);
      }
    } catch (error) {
      console.error('Failed to record sale sync error:', error);
    }
  }

  // PRODUCTS CACHE MANAGEMENT
  async cacheProducts(products: Array<Omit<BreakeryDB['products']['value'], 'last_updated'>>): Promise<void> {
    const db = await this.ensureDB();
    const timestamp = new Date().toISOString();
    
    try {
      const tx = db.transaction('products', 'readwrite');
      const store = tx.objectStore('products');
      
      // Clear existing products
      await store.clear();
      
      // Add all products with timestamp
      for (const product of products) {
        await store.put({
          ...product,
          last_updated: timestamp,
        });
      }
      
      await tx.complete;
      console.log(`Cached ${products.length} products`);
    } catch (error) {
      console.error('Failed to cache products:', error);
      throw new Error('Could not cache products');
    }
  }

  async getCachedProducts(): Promise<BreakeryDB['products']['value'][]> {
    const db = await this.ensureDB();
    try {
      return await db.getAllFromIndex('products', 'is_active', true);
    } catch (error) {
      console.error('Failed to get cached products:', error);
      return [];
    }
  }

  async getCachedProduct(id: string): Promise<BreakeryDB['products']['value'] | undefined> {
    const db = await this.ensureDB();
    try {
      return await db.get('products', id);
    } catch (error) {
      console.error('Failed to get cached product:', error);
      return undefined;
    }
  }

  // CATEGORIES CACHE MANAGEMENT
  async cacheCategories(categories: Array<Omit<BreakeryDB['categories']['value'], 'last_updated'>>): Promise<void> {
    const db = await this.ensureDB();
    const timestamp = new Date().toISOString();
    
    try {
      const tx = db.transaction('categories', 'readwrite');
      const store = tx.objectStore('categories');
      
      await store.clear();
      
      for (const category of categories) {
        await store.put({
          ...category,
          last_updated: timestamp,
        });
      }
      
      await tx.complete;
      console.log(`Cached ${categories.length} categories`);
    } catch (error) {
      console.error('Failed to cache categories:', error);
    }
  }

  async getCachedCategories(): Promise<BreakeryDB['categories']['value'][]> {
    const db = await this.ensureDB();
    try {
      return await db.getAllFromIndex('categories', 'is_active', true);
    } catch (error) {
      console.error('Failed to get cached categories:', error);
      return [];
    }
  }

  // STATISTICS AND MONITORING
  async getOfflineStats(): Promise<{
    pendingSales: number;
    cachedProducts: number;
    cachedCategories: number;
    failedSyncs: number;
    lastCacheUpdate?: string;
  }> {
    const db = await this.ensureDB();
    
    try {
      const [pendingSales, cachedProducts, cachedCategories] = await Promise.all([
        db.getAllFromIndex('sales', 'synced', false),
        db.getAll('products'),
        db.getAll('categories'),
      ]);

      const failedSyncs = pendingSales.filter(sale => sale.sync_attempts > 0).length;
      const lastCacheUpdate = cachedProducts.length > 0 
        ? cachedProducts[0]?.last_updated 
        : undefined;

      return {
        pendingSales: pendingSales.length,
        cachedProducts: cachedProducts.length,
        cachedCategories: cachedCategories.length,
        failedSyncs,
        lastCacheUpdate,
      };
    } catch (error) {
      console.error('Failed to get offline stats:', error);
      return {
        pendingSales: 0,
        cachedProducts: 0,
        cachedCategories: 0,
        failedSyncs: 0,
      };
    }
  }

  // CLEANUP
  async clearCache(): Promise<void> {
    const db = await this.ensureDB();
    
    try {
      const tx = db.transaction(['products', 'categories'], 'readwrite');
      await Promise.all([
        tx.objectStore('products').clear(),
        tx.objectStore('categories').clear(),
      ]);
      await tx.complete;
      console.log('Cache cleared');
    } catch (error) {
      console.error('Failed to clear cache:', error);
    }
  }

  async clearSyncedSales(): Promise<void> {
    const db = await this.ensureDB();
    
    try {
      const syncedSales = await db.getAllFromIndex('sales', 'synced', true);
      const tx = db.transaction('sales', 'readwrite');
      
      for (const sale of syncedSales) {
        await tx.objectStore('sales').delete(sale.id);
      }
      
      await tx.complete;
      console.log(`Cleared ${syncedSales.length} synced sales`);
    } catch (error) {
      console.error('Failed to clear synced sales:', error);
    }
  }
}

export const offlineService = new OfflineService();
```

#### 2. Sync Service - Background Synchronization

```typescript
// src/services/syncService.ts
import { supabase } from './supabase';
import { offlineService } from './offlineService';

export interface SyncResult {
  success: boolean;
  syncedCount: number;
  failedCount: number;
  errors: Array<{ id: string; error: string }>;
}

class SyncService {
  private isCurrentlySyncing = false;
  private syncInterval: number | null = null;
  private readonly MAX_RETRY_ATTEMPTS = 3;
  private readonly SYNC_INTERVAL_MS = 30000; // 30 seconds

  constructor() {
    // Listen for online events
    window.addEventListener('online', () => {
      console.log('Network restored, starting sync');
      this.startPeriodicSync();
      this.syncPendingTransactions();
    });

    window.addEventListener('offline', () => {
      console.log('Network lost, stopping periodic sync');
      this.stopPeriodicSync();
    });

    // Start periodic sync if online
    if (navigator.onLine) {
      this.startPeriodicSync();
    }
  }

  startPeriodicSync(): void {
    if (this.syncInterval) return;
    
    this.syncInterval = window.setInterval(() => {
      this.syncPendingTransactions();
    }, this.SYNC_INTERVAL_MS);
    
    console.log('Started periodic sync');
  }

  stopPeriodicSync(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
      console.log('Stopped periodic sync');
    }
  }

  async syncPendingTransactions(): Promise<SyncResult> {
    if (this.isCurrentlySyncing) {
      console.log('Sync already in progress, skipping');
      return { success: true, syncedCount: 0, failedCount: 0, errors: [] };
    }

    if (!navigator.onLine) {
      console.log('Device offline, skipping sync');
      return { success: false, syncedCount: 0, failedCount: 0, errors: [] };
    }

    this.isCurrentlySyncing = true;
    
    try {
      const pendingSales = await offlineService.getPendingSales();
      console.log(`Syncing ${pendingSales.length} pending sales`);

      if (pendingSales.length === 0) {
        return { success: true, syncedCount: 0, failedCount: 0, errors: [] };
      }

      const results = await Promise.allSettled(
        pendingSales.map(sale => this.syncSingleSale(sale))
      );

      let syncedCount = 0;
      let failedCount = 0;
      const errors: Array<{ id: string; error: string }> = [];

      results.forEach((result, index) => {
        const sale = pendingSales[index];
        if (result.status === 'fulfilled' && result.value) {
          syncedCount++;
        } else {
          failedCount++;
          const error = result.status === 'rejected' 
            ? result.reason?.message || 'Unknown error'
            : 'Sync failed';
          errors.push({ id: sale.id, error });
        }
      });

      console.log(`Sync completed: ${syncedCount} synced, ${failedCount} failed`);
      
      return {
        success: failedCount === 0,
        syncedCount,
        failedCount,
        errors,
      };

    } catch (error) {
      console.error('Sync process failed:', error);
      return {
        success: false,
        syncedCount: 0,
        failedCount: 0,
        errors: [{ id: 'sync_process', error: error instanceof Error ? error.message : 'Sync process failed' }],
      };
    } finally {
      this.isCurrentlySyncing = false;
    }
  }

  private async syncSingleSale(sale: any): Promise<boolean> {
    // Check if we should skip this sale (too many attempts)
    if (sale.sync_attempts >= this.MAX_RETRY_ATTEMPTS) {
      console.log(`Skipping sale ${sale.id} - max retry attempts reached`);
      return false;
    }

    try {
      // Prepare sale data for Supabase
      const saleData = {
        id: sale.id,
        total: sale.total,
        payment_method: sale.payment_method,
        amount_paid: sale.amount_paid,
        change: sale.change,
        customer_id: sale.customer_id || null,
        created_at: sale.created_at,
        // Add user context if available
        user_id: supabase.auth.getUser().then(u => u.data.user?.id),
      };

      // Insert sale
      const { data: saleResult, error: saleError } = await supabase
        .from('sales')
        .insert([saleData])
        .select()
        .single();

      if (saleError) {
        throw new Error(`Sale insert failed: ${saleError.message}`);
      }

      // Insert order items
      const orderItems = sale.items.map((item: any) => ({
        sale_id: sale.id,
        product_id: item.product_id,
        quantity: item.quantity,
        price: item.price,
        subtotal: item.subtotal,
      }));

      const { error: itemsError } = await supabase
        .from('order_items')
        .insert(orderItems);

      if (itemsError) {
        // Try to clean up the sale if items failed
        await supabase.from('sales').delete().eq('id', sale.id);
        throw new Error(`Order items insert failed: ${itemsError.message}`);
      }

      // Update stock quantities
      for (const item of sale.items) {
        const { error: stockError } = await supabase.rpc('decrease_stock', {
          product_id: item.product_id,
          quantity: item.quantity,
        });

        if (stockError) {
          console.warn(`Stock update failed for product ${item.product_id}:`, stockError.message);
          // Don't fail the entire sync for stock errors - they can be handled separately
        }
      }

      // Mark as synced
      await offlineService.markSaleAsSynced(sale.id);
      console.log(`Successfully synced sale: ${sale.id}`);
      return true;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown sync error';
      console.error(`Failed to sync sale ${sale.id}:`, errorMessage);
      
      // Record the error
      await offlineService.markSaleSyncError(sale.id, errorMessage);
      return false;
    }
  }

  async syncProductsCache(): Promise<void> {
    if (!navigator.onLine) {
      console.log('Device offline, cannot sync products cache');
      return;
    }

    try {
      // Fetch fresh products data
      const { data: products, error: productsError } = await supabase
        .from('products')
        .select('*')
        .eq('is_active', true);

      if (productsError) {
        throw new Error(`Failed to fetch products: ${productsError.message}`);
      }

      if (products) {
        await offlineService.cacheProducts(products);
      }

      // Fetch categories
      const { data: categories, error: categoriesError } = await supabase
        .from('categories')
        .select('*')
        .eq('is_active', true);

      if (categoriesError) {
        console.warn('Failed to fetch categories:', categoriesError.message);
      } else if (categories) {
        await offlineService.cacheCategories(categories);
      }

      console.log('Products and categories cache updated');
    } catch (error) {
      console.error('Failed to sync products cache:', error);
      throw error;
    }
  }

  async forceSyncAll(): Promise<SyncResult> {
    console.log('Force sync initiated');
    this.isCurrentlySyncing = false; // Reset flag to allow force sync
    
    // First sync products cache
    try {
      await this.syncProductsCache();
    } catch (error) {
      console.error('Failed to sync products cache during force sync:', error);
    }

    // Then sync pending transactions
    return await this.syncPendingTransactions();
  }

  getCurrentSyncStatus(): { isCurrentlySyncing: boolean; isPeriodicSyncActive: boolean } {
    return {
      isCurrentlySyncing: this.isCurrentlySyncing,
      isPeriodicSyncActive: this.syncInterval !== null,
    };
  }

  destroy(): void {
    this.stopPeriodicSync();
    window.removeEventListener('online', this.syncPendingTransactions);
    window.removeEventListener('offline', this.stopPeriodicSync.bind(this));
  }
}

export const syncService = new SyncService();
```

#### 3. Network Status Hook

```typescript
// src/hooks/useNetworkStatus.ts
import { useState, useEffect } from 'react';

export interface NetworkStatus {
  isOnline: boolean;
  isSlowConnection: boolean;
  connectionType?: string;
  effectiveType?: string;
}

export function useNetworkStatus(): NetworkStatus {
  const [networkStatus, setNetworkStatus] = useState<NetworkStatus>({
    isOnline: navigator.onLine,
    isSlowConnection: false,
    connectionType: 'unknown',
    effectiveType: 'unknown',
  });

  useEffect(() => {
    const updateNetworkStatus = () => {
      const connection = (navigator as any).connection 
        || (navigator as any).mozConnection 
        || (navigator as any).webkitConnection;

      const isSlowConnection = connection 
        ? ['slow-2g', '2g'].includes(connection.effectiveType)
        : false;

      setNetworkStatus({
        isOnline: navigator.onLine,
        isSlowConnection,
        connectionType: connection?.type || 'unknown',
        effectiveType: connection?.effectiveType || 'unknown',
      });
    };

    const handleOnline = () => {
      updateNetworkStatus();
      console.log('Network: Online');
    };

    const handleOffline = () => {
      updateNetworkStatus();
      console.log('Network: Offline');
    };

    const handleConnectionChange = () => {
      updateNetworkStatus();
      console.log('Network: Connection changed');
    };

    // Set initial status
    updateNetworkStatus();

    // Add event listeners
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    const connection = (navigator as any).connection 
      || (navigator as any).mozConnection 
      || (navigator as any).webkitConnection;

    if (connection) {
      connection.addEventListener('change', handleConnectionChange);
    }

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
      
      if (connection) {
        connection.removeEventListener('change', handleConnectionChange);
      }
    };
  }, []);

  return networkStatus;
}
```

#### 4. Offline Sync Hook

```typescript
// src/hooks/useOfflineSync.ts
import { useState, useEffect, useCallback } from 'react';
import { offlineService } from '../services/offlineService';
import { syncService, SyncResult } from '../services/syncService';
import { useNetworkStatus } from './useNetworkStatus';

export interface OfflineStats {
  pendingSales: number;
  cachedProducts: number;
  cachedCategories: number;
  failedSyncs: number;
  lastCacheUpdate?: string;
}

export interface UseOfflineSyncReturn {
  // Status
  isOnline: boolean;
  isSlowConnection: boolean;
  isSyncing: boolean;
  
  // Stats
  stats: OfflineStats;
  
  // Actions
  forcSync: () => Promise<SyncResult>;
  refreshCache: () => Promise<void>;
  clearOfflineData: () => Promise<void>;
  
  // Sale management
  saveOfflineSale: (sale: any) => Promise<void>;
  
  // Last sync result
  lastSyncResult: SyncResult | null;
  
  // Refresh stats
  refreshStats: () => Promise<void>;
}

export function useOfflineSync(): UseOfflineSyncReturn {
  const networkStatus = useNetworkStatus();
  const [isSyncing, setIsSyncing] = useState(false);
  const [stats, setStats] = useState<OfflineStats>({
    pendingSales: 0,
    cachedProducts: 0,
    cachedCategories: 0,
    failedSyncs: 0,
  });
  const [lastSyncResult, setLastSyncResult] = useState<SyncResult | null>(null);

  // Initialize offline service
  useEffect(() => {
    const initOffline = async () => {
      try {
        await offlineService.init();
        await refreshStats();
        console.log('Offline service initialized');
      } catch (error) {
        console.error('Failed to initialize offline service:', error);
      }
    };

    initOffline();
  }, []);

  // Refresh stats
  const refreshStats = useCallback(async () => {
    try {
      const newStats = await offlineService.getOfflineStats();
      setStats(newStats);
    } catch (error) {
      console.error('Failed to refresh offline stats:', error);
    }
  }, []);

  // Auto-refresh stats every 10 seconds
  useEffect(() => {
    const interval = setInterval(refreshStats, 10000);
    return () => clearInterval(interval);
  }, [refreshStats]);

  // Force sync
  const forceSync = useCallback(async (): Promise<SyncResult> => {
    if (isSyncing) {
      console.log('Sync already in progress');
      return { success: false, syncedCount: 0, failedCount: 0, errors: [] };
    }

    setIsSyncing(true);
    try {
      const result = await syncService.forceSyncAll();
      setLastSyncResult(result);
      await refreshStats();
      return result;
    } catch (error) {
      const errorResult: SyncResult = {
        success: false,
        syncedCount: 0,
        failedCount: 0,
        errors: [{ id: 'sync_error', error: error instanceof Error ? error.message : 'Unknown error' }],
      };
      setLastSyncResult(errorResult);
      return errorResult;
    } finally {
      setIsSyncing(false);
    }
  }, [isSyncing, refreshStats]);

  // Refresh cache
  const refreshCache = useCallback(async (): Promise<void> => {
    try {
      await syncService.syncProductsCache();
      await refreshStats();
    } catch (error) {
      console.error('Failed to refresh cache:', error);
      throw error;
    }
  }, [refreshStats]);

  // Clear offline data
  const clearOfflineData = useCallback(async (): Promise<void> => {
    try {
      await offlineService.clearCache();
      await offlineService.clearSyncedSales();
      await refreshStats();
    } catch (error) {
      console.error('Failed to clear offline data:', error);
      throw error;
    }
  }, [refreshStats]);

  // Save offline sale
  const saveOfflineSale = useCallback(async (sale: any): Promise<void> => {
    try {
      await offlineService.saveOfflineSale({
        ...sale,
        created_at: sale.created_at || new Date().toISOString(),
      });
      await refreshStats();

      // Try immediate sync if online
      if (networkStatus.isOnline && !isSyncing) {
        forceSync();
      }
    } catch (error) {
      console.error('Failed to save offline sale:', error);
      throw error;
    }
  }, [networkStatus.isOnline, isSyncing, forceSync, refreshStats]);

  return {
    // Status
    isOnline: networkStatus.isOnline,
    isSlowConnection: networkStatus.isSlowConnection,
    isSyncing,
    
    // Stats
    stats,
    
    // Actions
    forcSync: forceSync,
    refreshCache,
    clearOfflineData,
    saveOfflineSale,
    
    // Results
    lastSyncResult,
    refreshStats,
  };
}
```

#### 5. Offline Indicator Component

```typescript
// src/components/ui/OfflineIndicator.tsx
import React, { useState } from 'react';
import { useOfflineSync } from '../../hooks/useOfflineSync';
import { LoadingSpinner } from './LoadingSpinner';

export const OfflineIndicator: React.FC = () => {
  const { 
    isOnline, 
    isSlowConnection, 
    isSyncing, 
    stats, 
    forcSync, 
    refreshCache,
    lastSyncResult 
  } = useOfflineSync();
  
  const [isExpanded, setIsExpanded] = useState(false);

  const getStatusColor = () => {
    if (!isOnline) return 'bg-red-500';
    if (isSyncing) return 'bg-yellow-500';
    if (stats.pendingSales > 0) return 'bg-orange-500';
    if (stats.failedSyncs > 0) return 'bg-yellow-600';
    return 'bg-green-500';
  };

  const getStatusText = () => {
    if (!isOnline) return 'Mode Hors Ligne';
    if (isSyncing) return 'Synchronisation...';
    if (stats.pendingSales > 0) return `${stats.pendingSales} vente(s) en attente`;
    if (stats.failedSyncs > 0) return `${stats.failedSyncs} échec(s) de sync`;
    return 'En Ligne';
  };

  const handleSyncClick = async () => {
    try {
      await forcSync();
    } catch (error) {