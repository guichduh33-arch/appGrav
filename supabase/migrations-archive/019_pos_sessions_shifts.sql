-- Migration: POS Sessions (Shifts) Management
-- Generated by ERPDesignAgent
-- Description: Gestion des sessions de caisse (shifts) avec anti-fraude

-- ============================================
-- TABLE: pos_sessions
-- ============================================
CREATE TABLE IF NOT EXISTS pos_sessions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    session_number VARCHAR(50) UNIQUE NOT NULL,
    user_id UUID REFERENCES auth.users(id) NOT NULL,
    terminal_id VARCHAR(50),
    status VARCHAR(20) NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'closed', 'reconciled')),

    -- Timestamps
    opened_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    closed_at TIMESTAMPTZ,

    -- Opening
    opening_cash DECIMAL(15,2) NOT NULL DEFAULT 0,

    -- Expected amounts (calculated from orders)
    expected_cash DECIMAL(15,2) DEFAULT 0,
    expected_qris DECIMAL(15,2) DEFAULT 0,
    expected_edc DECIMAL(15,2) DEFAULT 0,

    -- Actual amounts (entered by cashier at closing)
    actual_cash DECIMAL(15,2),
    actual_qris DECIMAL(15,2),
    actual_edc DECIMAL(15,2),

    -- Differences (calculated after closing)
    cash_difference DECIMAL(15,2),
    qris_difference DECIMAL(15,2),
    edc_difference DECIMAL(15,2),

    -- Statistics
    total_sales DECIMAL(15,2) DEFAULT 0,
    transaction_count INTEGER DEFAULT 0,

    -- Notes and audit
    notes TEXT,
    closed_by UUID REFERENCES auth.users(id),
    reconciled_by UUID REFERENCES auth.users(id),
    reconciled_at TIMESTAMPTZ,

    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add user_id column if it doesn't exist (table may already exist from earlier migration)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'pos_sessions' AND column_name = 'user_id') THEN
        ALTER TABLE pos_sessions ADD COLUMN user_id UUID REFERENCES auth.users(id);
    END IF;
END $$;

-- Indexes
CREATE INDEX IF NOT EXISTS idx_pos_sessions_user ON pos_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_pos_sessions_status ON pos_sessions(status);
CREATE INDEX IF NOT EXISTS idx_pos_sessions_date ON pos_sessions(opened_at DESC);

-- Enable RLS
ALTER TABLE pos_sessions ENABLE ROW LEVEL SECURITY;

-- RLS Policies
DROP POLICY IF EXISTS "Users can view their own sessions" ON pos_sessions;
CREATE POLICY "Users can view their own sessions" ON pos_sessions
    FOR SELECT TO authenticated
    USING (user_id = auth.uid() OR EXISTS (
        SELECT 1 FROM user_profiles WHERE user_id = auth.uid() AND role IN ('admin', 'manager')
    ));

DROP POLICY IF EXISTS "Users can create their own sessions" ON pos_sessions;
CREATE POLICY "Users can create their own sessions" ON pos_sessions
    FOR INSERT TO authenticated
    WITH CHECK (user_id = auth.uid());

DROP POLICY IF EXISTS "Users can update their own open sessions" ON pos_sessions;
CREATE POLICY "Users can update their own open sessions" ON pos_sessions
    FOR UPDATE TO authenticated
    USING (user_id = auth.uid() OR EXISTS (
        SELECT 1 FROM user_profiles WHERE user_id = auth.uid() AND role IN ('admin', 'manager')
    ));

-- Function to generate session number
DROP FUNCTION IF EXISTS generate_session_number() CASCADE;
CREATE OR REPLACE FUNCTION generate_session_number()
RETURNS VARCHAR(50) AS $$
DECLARE
    v_date TEXT;
    v_count INTEGER;
    v_number VARCHAR(50);
BEGIN
    v_date := TO_CHAR(NOW(), 'YYYYMMDD');

    SELECT COUNT(*) + 1 INTO v_count
    FROM pos_sessions
    WHERE DATE(opened_at) = CURRENT_DATE;

    v_number := 'SHIFT-' || v_date || '-' || LPAD(v_count::TEXT, 3, '0');

    RETURN v_number;
END;
$$ LANGUAGE plpgsql;

-- Function to open a new shift
CREATE OR REPLACE FUNCTION open_shift(
    p_user_id UUID,
    p_opening_cash DECIMAL,
    p_terminal_id VARCHAR DEFAULT NULL,
    p_notes TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
    v_session_id UUID;
    v_existing_session UUID;
BEGIN
    -- Check if user has an open session
    SELECT id INTO v_existing_session
    FROM pos_sessions
    WHERE user_id = p_user_id AND status = 'open';

    IF v_existing_session IS NOT NULL THEN
        RAISE EXCEPTION 'User already has an open shift';
    END IF;

    -- Create new session
    INSERT INTO pos_sessions (
        session_number,
        user_id,
        terminal_id,
        opening_cash,
        notes
    ) VALUES (
        generate_session_number(),
        p_user_id,
        p_terminal_id,
        p_opening_cash,
        p_notes
    ) RETURNING id INTO v_session_id;

    RETURN v_session_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to close a shift
CREATE OR REPLACE FUNCTION close_shift(
    p_session_id UUID,
    p_actual_cash DECIMAL,
    p_actual_qris DECIMAL,
    p_actual_edc DECIMAL,
    p_closed_by UUID,
    p_notes TEXT DEFAULT NULL
)
RETURNS JSONB AS $$
DECLARE
    v_session pos_sessions%ROWTYPE;
    v_expected_cash DECIMAL;
    v_expected_qris DECIMAL;
    v_expected_edc DECIMAL;
    v_total_sales DECIMAL;
    v_transaction_count INTEGER;
BEGIN
    -- Get session
    SELECT * INTO v_session FROM pos_sessions WHERE id = p_session_id;

    IF v_session IS NULL THEN
        RAISE EXCEPTION 'Session not found';
    END IF;

    IF v_session.status != 'open' THEN
        RAISE EXCEPTION 'Session is not open';
    END IF;

    -- Calculate expected amounts from orders during this shift
    SELECT
        COALESCE(SUM(CASE WHEN payment_method = 'cash' THEN total_amount ELSE 0 END), 0),
        COALESCE(SUM(CASE WHEN payment_method = 'qris' THEN total_amount ELSE 0 END), 0),
        COALESCE(SUM(CASE WHEN payment_method IN ('card', 'edc') THEN total_amount ELSE 0 END), 0),
        COALESCE(SUM(total_amount), 0),
        COUNT(*)
    INTO v_expected_cash, v_expected_qris, v_expected_edc, v_total_sales, v_transaction_count
    FROM orders
    WHERE created_at >= v_session.opened_at
      AND created_at <= NOW()
      AND status = 'completed';

    -- Add opening cash to expected cash
    v_expected_cash := v_expected_cash + v_session.opening_cash;

    -- Update session with closing data
    UPDATE pos_sessions SET
        status = 'closed',
        closed_at = NOW(),
        expected_cash = v_expected_cash,
        expected_qris = v_expected_qris,
        expected_edc = v_expected_edc,
        actual_cash = p_actual_cash,
        actual_qris = p_actual_qris,
        actual_edc = p_actual_edc,
        cash_difference = p_actual_cash - v_expected_cash,
        qris_difference = p_actual_qris - v_expected_qris,
        edc_difference = p_actual_edc - v_expected_edc,
        total_sales = v_total_sales,
        transaction_count = v_transaction_count,
        closed_by = p_closed_by,
        notes = COALESCE(p_notes, v_session.notes),
        updated_at = NOW()
    WHERE id = p_session_id;

    -- Return reconciliation data
    RETURN jsonb_build_object(
        'session_id', p_session_id,
        'status', 'closed',
        'total_sales', v_total_sales,
        'transaction_count', v_transaction_count,
        'reconciliation', jsonb_build_object(
            'cash', jsonb_build_object(
                'expected', v_expected_cash,
                'actual', p_actual_cash,
                'difference', p_actual_cash - v_expected_cash
            ),
            'qris', jsonb_build_object(
                'expected', v_expected_qris,
                'actual', p_actual_qris,
                'difference', p_actual_qris - v_expected_qris
            ),
            'edc', jsonb_build_object(
                'expected', v_expected_edc,
                'actual', p_actual_edc,
                'difference', p_actual_edc - v_expected_edc
            )
        )
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to update updated_at
CREATE OR REPLACE FUNCTION update_pos_sessions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_pos_sessions_updated_at ON pos_sessions;
CREATE TRIGGER trg_pos_sessions_updated_at
    BEFORE UPDATE ON pos_sessions
    FOR EACH ROW
    EXECUTE FUNCTION update_pos_sessions_updated_at();
